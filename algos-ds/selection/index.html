<!DOCTYPE html>
<html lang="en-us">

<head>
  <title>Selection | Aditya Bhatia Blog!</title>

  <meta charset="UTF-8">
  <meta name="language" content="en">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  
  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Selection" />
  <meta name="twitter:description" content=""/>
  <meta name="twitter:site" content="https://twitter.com/tuubow" />
  <meta name="twitter:creator" content="https://twitter.com/tuubow" />
  

  <link rel="shortcut icon" type="image/png" href="/favicon.ico" />

  
  
    
 
  
  
  
  
  
  
    
    <link type="text/css" rel="stylesheet" href="/css/post.min.2cb93c91050d1853bf971cc31e00122edd6e0f405aa1de3b7f8ef67ea3b5a79a.css" integrity="sha256-LLk8kQUNGFO/lxzDHgASLt1uD0Baod47f472fqO1p5o="/>
  
    
    <link type="text/css" rel="stylesheet" href="/css/custom.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css" integrity="sha256-47DEQpj8HBSa&#43;/TImW&#43;5JCeuQeRkm5NMpJWZG3hSuFU="/>
  
  
   
   
    

<script type="application/ld+json">
  
    { 
      "@context": "http://schema.org", 
      "@type": "WebSite", 
      "url": "http:\/\/adityabhatia.com\/algos-ds\/selection\/",
      "name": "Selection",
      "author": {
        "@type": "Person",
        "name": ""
      },
      "description": ""
    }
  
  </script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-179391611-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</head>

<body>
  <div class="burger__container">
  <div class="burger" aria-controls="navigation" aria-label="Menu">
    <div class="burger__meat burger__meat--1"></div>
    <div class="burger__meat burger__meat--2"></div>
    <div class="burger__meat burger__meat--3"></div>
  </div>
</div>
 

  <nav class="nav" id="navigation">
  <ul class="nav__list">
    
    
      <li>
        <a  href="/">About</a>
      </li>
    
      <li>
        <a  class="active"
         href="/algos-ds">Algos &amp; DS World!</a>
      </li>
    
      <li>
        <a  href="/go-world">Go World!</a>
      </li>
    
      <li>
        <a  href="/investments">Investment World</a>
      </li>
    
      <li>
        <a  href="/ml-world">ML World</a>
      </li>
    
      <li>
        <a  href="/thoughts">My Thoughts</a>
      </li>
    
      <li>
        <a  href="/python">Py World</a>
      </li>
    
      <li>
        <a  href="/scalable-world">Scalable World</a>
      </li>
    
  </ul>
</nav>


  <main>
    
    

    <div class="flex-wrapper">
      <div class="post__container">
        <div class="post">
          <header class="post__header">
            <h1 id="post__title">Selection</h1>
            <time datetime="2023-11-29 10:33:53 -0800 PST" class="post__date">Nov 29 2023</time> 
          </header>
          <article class="post__content">
              
<p>In this article will summarize mathematics related to selection of <code>k</code> items in <code>n</code> items and counting problems problems related to selection of items.</p>
<p>Let&rsquo;s first understand what n choose k means, i.e. choosing/selecting k items out of n items.</p>
<p>Let&rsquo;s take an example of <code>4 balls</code> of Red(R), Blue(B), Green(G), White(W) color and try to understand from that. Whenever we choose <code>k items</code> from <code>n items</code>, we can create a bucket of size <code>k</code> and put the items in that bucket, so the remaining items outside of bucket will be <code>n - k</code> at the end of the selection.</p>
<ul>
<li>Selecting <code>No ball</code> out of <code>4 balls</code> :-&gt; 1 way of doing that, as no selection is also a choice.</li>
<li>Selecting <code>1 ball</code> out of <code>4 balls</code> :-&gt; This is quite simple, as each of the ball can be selected and but in the bucket. The bucket with all the four balls in each selection i.e. <code>{R,G,B,W}</code></li>
<li>Selecting <code>2 balls</code> out of <code>4 balls</code> :-&gt; This gives us multiple selections let&rsquo;s iterate those, <code>{RB, RG, RW, BG, BW, GW}</code> this can be done by selecting and putting a ball in the bucket from <code>{R,G,B,W}</code>, and then selecting again with the remaining <code>3 balls</code> to fill the bucket of size 2.</li>
<li>Selecting <code>3 balls</code> out of <code>4 balls</code> :-&gt; There are 4 ways for selecting 3 balls, and can be given as : <code>{RGB,RGW,RBW,GBW}</code>. This step is in symmetry with selecting <code>1 ball</code> out of 4 as the problem can also be rephrased as not selecting 1 ball from the 4 balls, thus remaining 3 balls left. In each iteration we don&rsquo;t select one ball and the remaining sequence becomes the selection.</li>
<li>Selecting all <code>4 balls</code> out of <code>4 balls</code> :-&gt; There is only one way to do so. This again is in symmetry with the no ball selection as no ball selection is same as all ball selection for the remaining balls.</li>
</ul>
<p>Now the number of ways for this selection is denoted by <code>^n^C~r~</code> or <code>(n r)</code>.</p>
<p>Mathematically <code>^n^C~k~</code> is equal to <code>n!/k!(n-k)!</code>. Let&rsquo;s try to understand how we reach to this closed form formula.</p>
<p>The numerator of <code>n!</code> is defined by number of ways to arrange n items, this can be reasoned by thinking of arrangement as <code>n blanks</code> and the first blank can be filled with any of the <code>n item</code> so n ways, once the first blank is filled the second can be filled with any of the <code>n-1 items</code> and so forth the last <code>nth blank</code> can be filled with only 1 item remaining. This leads to <code>n * (n - 1) * (n - 2) * (n - 3) ... 1</code> which is n!. For <code>n = 4</code> these would be <code>24</code> arrangements.</p>
<p>Now an imaginary boundary can be thought between these <code>n blanks</code> such that on the left side there are <code>k blanks</code> and on the right side <code>n - k blanks</code>, this will help to understand the denominator.  In case of n = 4 and k = 2 this would be <code>_ _ | _ _</code>. Now if we fill all the <code>n!</code> <code>24</code> arrangements in these spaces for <code>n = 4</code>. Then we can see that the first <code>2 blanks</code> will contain all the selections for example <code>{RG, GR, RB, BR, RW, WR, GB, BG, BW, WB, GW, WG}</code>. But in these selections <code>BW</code> and <code>WB</code> are considered as two selections, and similarly for other like <code>BG, GB</code> or <code>RB, BR</code> etc. In fact there are only 6 unique selections without considering the order. That is why we need to divide it by the number of arrangements which are possible in the <code>k blanks</code> and that would be <code>k!</code>. This will make sure all the inter arrangements between the <code>k blanks</code> due to different order of the same items is only considered once. A similar analysis can be done for the remaining <code>(n - k) blanks</code>, so we take only the unique selection of elements only once irrespective of order. This can be done by dividing with <code>(n-k)!</code>.</p>
<ul>
<li>Here to note we are not considering the order of selection as a separate selection, i.e. if there are <code>4 balls</code> of Red(R), Blue(B), Green(G), White(W) color then selection of 2 balls such that Red, White <code>{RW}</code> or White, Red <code>{WR}</code> is considered as 1 selection. In some problems this will be considered as two separate selections, for example selecting <code>2 digits</code> out of <code>1,2,3,4</code> as <code>12</code> and <code>21</code> are different numbers.</li>
</ul>
<ul>
<li>What would be the number of ways in such scenario? Hint: Here as the order is important, so we don&rsquo;t need to divide <code>n!</code> by <code>k!</code> as every sequence is a separate count in the selection. And so what is remaining is <code>n!/(n - k)!</code> which is defined as <code>^n^P~k~</code> or can also be given as <code>k! * ^n^C~k~</code>. Which is defined as, number of ways to arrange <code>k</code> items out of <code>n</code> items.</li>
</ul>
<p>Going further I will be referring <code>^n^C~k~</code> as <code>C(n, k)</code>, just to make it simpler to write it.</p>
<p>Let&rsquo;s look at the first problem</p>
<ul>
<li><a href="https://leetcode.com/problems/combinations/">Combinations</a></li>
</ul>
<p>Given n and k, return all possible combinations of k selection in n number from 1 to n.</p>
<p>One of the approaches for these problems is to create a <code>partial solution stack &lt;st&gt;</code> and pass that solution to the following recursive calls.
In the case of selecting k items in n items, the idea is to select by putting the element in the stack calling the recursive call with next item and unselecting it by removing the element from the stack and again calling the recursing call with next item. In that way each item is selected and unselected in each recursive call, till <code>k</code> items are present in the stack which is one of the solution.</p>
<pre><code class="language-Python">def combine(self, n: int, k: int) -&gt; List[List[int]]:
    sol = []
    def dfs(st: List[int], elem: int):
        if len(st) == k:
            sol.append(st[:])
            return
        if elem &lt;= n:
            st.append(elem)
            dfs(st, elem + 1)
            st.pop()
            dfs(st, elem + 1)
    dfs([], 1)
    return sol
</code></pre>
<p>Another way to think about this problem, at first position of k blanks, each number of n can be selected and the following k - 1 numbers can be selected for further positions. In this way basically at each recursive call each of the k blanks are filled.</p>
<pre><code class="language-Python">def combine(self, n: int, k: int) -&gt; List[List[int]]:
    sol = []
    def dfs(st: List[int], elem: int):
        if len(st) == k:
            sol.append(st[:])
            return
        for i in range(elem, n + 1):
            st.append(i)
            dfs(st, i + 1)
            st.pop()
    dfs([], 1)
    return sol
</code></pre>
<p>Time Complexity: Complexity of both the solutions will be equal to sum of inner nodes and k * each leaf node, due to copy operation at each leaf node. There will be <code>C(n, k)</code> leaf nodes in the recursive tree which will be added to solution. So complexity will be O(k * n!/k!(n-k)!) which can be said to have an O(n!/k!(n-k)!) or a bigger upper bound to O(n^k/k!),</p>
<p>This can be proven as <code>n!/k!(n-k)! =&gt; n*(n-1)*(n-2) ... (n - k + 1) / k!</code>
=&gt; Taking n as common in k numerator terms will give =&gt; <code>n^k * (1 - 1/n) * (1 - 2/n) ... (1 - (k + 1)/n)</code> which can be upper bounded by <code>n ^ k</code>.
=&gt; Giving <code>O(n^k/k!)</code></p>
<p>More information about the upper and lower bound of <code>C(n, k)</code> <a href="https://math.stackexchange.com/questions/1352338/proof-for-the-upper-bound-and-lower-bound-for-binomial-coefficients">link</a></p>


              
          </article>
          

 <div class="pagination">
  
    <a class="pagination__item" href="http://adityabhatia.com/algos-ds/dp-1/">
        <span class="pagination__label">Previous Post</span>
        <span class="pagination__title">Dynamic Programming (Part 1)</span>
    </a>
  

  
    <a class="pagination__item" href="http://adityabhatia.com/algos-ds/dp-2/">
      <span class="pagination__label">Next Post</span>
      <span class="pagination__title" >Dynamic Programming (Part 2)</a>
    </a>
  
</div>

          <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "adityabhatia-com" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          <footer class="post__footer">
            


<div class="social-icons">
  
     
    
      <a class="social-icons__link" title="Twitter"
         href="https://twitter.com/tuubow"
         target="_blank" rel="noopener">
        <div class="social-icons__icon" style="background-image: url('http://adityabhatia.com/svg/twitter.svg')"></div>
      </a>
    
  
     
    
      <a class="social-icons__link" title="GitHub"
         href="https://github.com/adityavit"
         target="_blank" rel="noopener">
        <div class="social-icons__icon" style="background-image: url('http://adityabhatia.com/svg/github.svg')"></div>
      </a>
    
     
</div>

            <p>Aditya Bhatia © 2022</p>
          </footer>
          </div>
      </div>
      
    </div>
    

  </main>

   

  
  <script src="/js/index.min.49e4d8a384357d9b445b87371863419937ede9fa77737522ffb633073aebfa44.js" integrity="sha256-SeTYo4Q1fZtEW4c3GGNBmTft6fp3c3Ui/7YzBzrr&#43;kQ=" crossorigin="anonymous"></script>
  
  
  <script src="https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js"></script>

  
  <script src="https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"
    data-autoloader-path="https://unpkg.com/prismjs@1.20.0/components/"></script>

  


</body>

</html>
