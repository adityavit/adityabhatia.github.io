<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scalable-worlds on Aditya Bhatia Blog!</title>
    <link>http://adityabhatia.com/scalable-world/</link>
    <description>Recent content in Scalable-worlds on Aditya Bhatia Blog!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Aditya Bhatia Â© 2022</copyright>
    <lastBuildDate>Wed, 28 Feb 2024 12:57:04 -0800</lastBuildDate>
    
	<atom:link href="http://adityabhatia.com/scalable-world/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Concurrency Patterns</title>
      <link>http://adityabhatia.com/scalable-world/concurrency-patterns/</link>
      <pubDate>Wed, 28 Feb 2024 12:57:04 -0800</pubDate>
      
      <guid>http://adityabhatia.com/scalable-world/concurrency-patterns/</guid>
      <description>This article explains some of the patterns related to concurrent problems. These patterns can be reused across multiple problems. Some of these patterns have been borrowed from the book Concurrency in Go and has been kept here for a quick reference.
So in this post I will add the templates related to concurrency problems and patterns related to that!
So, let&amp;rsquo;s start with what is Concurrency?
Concurrency is way to execute sections of code in an interleave manner.</description>
    </item>
    
    <item>
      <title>Quick back of the envelope calculations</title>
      <link>http://adityabhatia.com/scalable-world/design-calculations/</link>
      <pubDate>Fri, 16 Feb 2024 17:29:48 -0800</pubDate>
      
      <guid>http://adityabhatia.com/scalable-world/design-calculations/</guid>
      <description>In the design, it sometimes is important to get a rough estimate about the amount of server or boxes which will be needed to support a scale. In this post, I would like to summarize some of the quick hacks to estimate the number of machines based on multiple parameters.
First let&amp;rsquo;s do mapping between 2^x and 10^y for data estimation.
* 2^1 =&amp;gt; 2 (1 bit can represent 2 items 0, 1) * 2^2 =&amp;gt; 4 (2 bits can represent 4 items 00, 01, 10, 11) * 2^3 =&amp;gt; 8 (can represent 8 items, octal system) * 2^4 =&amp;gt; 16 (can represent 16 items, hexadecimal system 0-F, two hexadecimal characters form a byte) * 2^5 =&amp;gt; 32 * 2^6 =&amp;gt; 64 * 2^7 =&amp;gt; 128 (Can represent ASCII, in a byte (8 bits)) * 2^8 =&amp;gt; 256 (Represent ISO-8859-1 and multiple number of bytes form UTF-8) * 2^9 =&amp;gt; 512 * 2^10 =&amp;gt; 1 KB --&amp;gt; 10^3 bytes (Thousand) * 2^20 =&amp;gt; 1 MB --&amp;gt; 10^6 bytes (Million) * 2^30 =&amp;gt; 1 GB --&amp;gt; 10^9 bytes (Billion) * 2^40 =&amp;gt; 1 TB --&amp;gt; 10^12 bytes (Trillion) * 2^50 =&amp;gt; 1 PB --&amp;gt; 10^15 bytes (Quadrillion)  Using a the above table you can quickly calculate for example how many 2^48 (8 TB) in 10 index:</description>
    </item>
    
    <item>
      <title>Object Oriented Design (OOD)</title>
      <link>http://adityabhatia.com/scalable-world/design-patterns/</link>
      <pubDate>Mon, 05 Feb 2024 12:31:40 -0800</pubDate>
      
      <guid>http://adityabhatia.com/scalable-world/design-patterns/</guid>
      <description>SOLID design principles  Let&amp;rsquo;s start this article with going over the SOLID design principles for Object Oriented design and then seeing how the listed design pattern captures the some of the principles defined in it.
  S: Single Responsibility Based on this principle, a class definition should focus on single responsibility. A class should not try to encapsulate the business logic for doing multiple things, rather it should focus on doing just one thing and delegate other logic to objects of classes responsible for doing just that.</description>
    </item>
    
  </channel>
</rss>